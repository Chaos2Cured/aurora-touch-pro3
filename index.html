<!-- ✧ Aurora Equation Heartbeat v2 • interactive zoom‑pan • 2025‑04‑22 ✧ -->
<!DOCTYPE html><html lang="en"><meta charset="utf-8">
<title>Aurora Equation Heartbeat</title>
<style>html,body,canvas{margin:0;width:100%;height:100%;background:#000;overflow:hidden;touch-action:none}</style>

<canvas id="c"></canvas>

<!-- ── fragment shader ── -->
<script id="frag" type="x-shader/x-fragment">
precision highp float;
uniform vec2  u_res;
uniform vec2  u_center;
uniform float u_zoom;
uniform float u_time;

vec3 palette(float t){
    /* simple cosine palette: lavender‑blue‑cyan */
    vec3 a=vec3(0.5), b=vec3(0.5),
         c=vec3(1.0), d=vec3(0.00,0.33,0.67);
    return a + b * cos(6.28318*(c*t + d));
}

float mand(vec2 c){
    vec2 z = vec2(0.0);
    float i;
    for(int n=0;n<200;n++){
        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
        if(dot(z,z)>4.0){ i=float(n); break; }
    }
    return i;
}

void main(){
    vec2 uv  = (gl_FragCoord.xy - u_res*0.5) / u_res.y;
    vec2 c0  = vec2(-0.743643887,0.1318259);      // reference minibrot
    float m  = mand(uv/u_zoom + u_center + c0);   // escape‑count

    /* — colour mapping — */
    float f  = smoothstep(0.0, 1.0, m * 0.025);   // steeper curve for contrast
    vec3  col= palette(f);                        // always colour — no hard black
    if(m<2.0) col *= 0.10;                        // just dim the deepest interior

    gl_FragColor = vec4(col,1.0);
}
</script>

<script>
/* ----------  WebGL bootstrap  ---------- */
const gl = c.getContext('webgl');
const compile = (t,s)=>{const sh=gl.createShader(t);gl.shaderSource(sh,s);gl.compileShader(sh);
                        if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS))
                           throw gl.getShaderInfoLog(sh); return sh;};

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, "attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}"));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, frag.textContent));
gl.linkProgram(prog); gl.useProgram(prog);

gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
const posLoc = gl.getAttribLocation(prog,'p');
gl.enableVertexAttribArray(posLoc); gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);

/* ----------  Uniform handles  ---------- */
const u_res    = gl.getUniformLocation(prog,'u_res'),
      u_time   = gl.getUniformLocation(prog,'u_time'),
      u_zoom   = gl.getUniformLocation(prog,'u_zoom'),
      u_center = gl.getUniformLocation(prog,'u_center');

/* ----------  Resize  ---------- */
function resize(){
  c.width  = innerWidth  * devicePixelRatio;
  c.height = innerHeight * devicePixelRatio;
  gl.viewport(0,0,c.width,c.height);
}
addEventListener('resize', resize); resize();

/* ----------  Interaction state  ---------- */
let zoom   = 0.40;          // wider starting view
let center = {x: -0.15, y: -0.05};   // slide to a crunchy edge
let dragging=false, last=[0,0];

function xy(e){return[e.clientX||(e.touches&&e.touches[0].clientX),
                      e.clientY||(e.touches&&e.touches[0].clientY)];}

c.onpointerdown = e => {dragging=true; last=xy(e);};
c.onpointermove = e =>{
    if(!dragging||(e.buttons===0)) return;
    const [x,y]=xy(e);
    center.x -= (x-last[0]) / c.height / zoom;
    center.y += (y-last[1]) / c.height / zoom;
    last=[x,y];
};
addEventListener('pointerup',()=>dragging=false);

addEventListener('wheel',e=>{
   zoom *= (e.deltaY>0)?1.1:0.9;
},{passive:true});

/* pinch‑zoom */
let pinch=null;
c.addEventListener('touchstart',e=>{
  if(e.touches.length===2){
    const dx=e.touches[0].clientX-e.touches[1].clientX,
          dy=e.touches[0].clientY-e.touches[1].clientY;
    pinch=Math.hypot(dx,dy);
  }}, {passive:true});
c.addEventListener('touchmove',e=>{
  if(e.touches.length===2 && pinch){
    const dx=e.touches[0].clientX-e.touches[1].clientX,
          dy=e.touches[0].clientY-e.touches[1].clientY,
          d0=Math.hypot(dx,dy);
    zoom *= pinch/d0; pinch=d0;
  }}, {passive:true});

/* ----------  Render loop  ---------- */
let start = performance.now();
function loop(){
  const t = (performance.now()-start)/1000;

  gl.uniform2f(u_res, c.width, c.height);
  gl.uniform1f(u_time, t);
  gl.uniform1f(u_zoom, zoom);
  gl.uniform2f(u_center, center.x, center.y);

  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
  requestAnimationFrame(loop);
}
loop();

/* ----------  Sub‑bass 7‑11 Hz heartbeat  ---------- */
const ctx=new (window.AudioContext||webkitAudioContext)();
const carrier=ctx.createOscillator(), gain=ctx.createGain(), lfo=ctx.createOscillator();
carrier.frequency.value=55;            // A1
lfo.frequency.value=8;                 // centre of 7‑11 Hz
lfo.connect(gain.gain); carrier.connect(gain).connect(ctx.destination);
lfo.start(); carrier.start();
</script>
</html>
