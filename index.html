<!-- ✧ Aurora‑Equation Heartbeat v2.2  ·  bright‑rainbow & centred zoom · 2025‑04‑23 ✧ -->
<!DOCTYPE html><html lang="en"><meta charset="utf-8">
<title>Aurora Equation Heartbeat</title>
<style>
html,body,canvas{margin:0;width:100%;height:100%;background:#000;overflow:hidden;touch-action:none}
</style>

<canvas id="c"></canvas>

<!-- ────────────────── fragment shader ────────────────── -->
<script id="frag" type="x-shader/x-fragment">
precision highp float;

uniform vec2  u_res;      /* canvas resolution (px)           */
uniform vec2  u_center;   /* complex-plane centre (re, im)    */
uniform float u_zoom;     /* pixels‑per‑unit scaling           */
uniform float u_iter;     /* max iterations (from JS)         */

/* vivid rainbow cosine palette */
vec3 palette(float t){
    return 0.55 + 0.45 * cos(6.28318*(
             t + vec3(0.00,0.33,0.67))); /* R‑G‑B phase offsets */
}

/* basic (unsmoothed) escape‐time */
float mand(vec2 c){
    vec2 z = vec2(0.0);
    for(int n=0;n<2000;n++){
        if(float(n) >= u_iter) return u_iter;        /* inside – colour by maxIter */
        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
        if(dot(z,z) > 4.0) return float(n);
    }
    return u_iter;
}

void main(){
    /* map pixel‑coords → complex plane */
    vec2 uv = (gl_FragCoord.xy - u_res*0.5) / u_res.y / u_zoom + u_center;

    float m = mand(uv);                   /* escape iteration */

    /* continuous normalisation for smoother colour */
    float f = clamp(m / u_iter, 0.0, 1.0);

    vec3 col = palette(f);

    /* dim deep interior slightly (never dead‑black) */
    col *= mix(0.15, 1.0, f);

    /* golden rim on fast‑escape zones */
    float rim = smoothstep(0.75, 1.0, f);
    col = mix(col, vec3(1.0,0.78,0.25), rim*0.25);

    gl_FragColor = vec4(col,1.0);
}
</script>

<!-- ──────────────── JavaScript glue ──────────────── -->
<script>
/* ------ WebGL boilerplate ------ */
const gl = c.getContext('webgl');
const compile = (type, src) => {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS))
       throw gl.getShaderInfoLog(s);
  return s;
};
const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER,
  "attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}"));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER,
  document.getElementById('frag').textContent));
gl.linkProgram(prog);  gl.useProgram(prog);

gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
const pos = gl.getAttribLocation(prog,'p');
gl.enableVertexAttribArray(pos);
gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);

/* ------ uniforms ------ */
const uR = gl.getUniformLocation(prog,'u_res'),
      uZ = gl.getUniformLocation(prog,'u_zoom'),
      uC = gl.getUniformLocation(prog,'u_center'),
      uI = gl.getUniformLocation(prog,'u_iter');

/* ------ resize ------ */
function resize(){
  c.width  = innerWidth  * devicePixelRatio;
  c.height = innerHeight * devicePixelRatio;
  gl.viewport(0,0,c.width,c.height);
  gl.uniform2f(uR, c.width, c.height);
}
addEventListener('resize', resize); resize();

/* ------ interaction state ------ */
let zoom   = 1.0;                               /* start fairly close‑in  */
let center = { x: -0.743643887, y: 0.1318259 }; /* minibrot nucleus       */

let dragging = false, last=[0,0];
function xy(e){ return [
  e.clientX || (e.touches && e.touches[0].clientX),
  e.clientY || (e.touches && e.touches[0].clientY)
];}
c.onpointerdown = e => { dragging=true; last=xy(e); };
c.onpointermove = e => {
  if(!dragging || e.buttons===0) return;
  const [x,y] = xy(e);
  center.x -= (x-last[0]) / c.height / zoom;
  center.y += (y-last[1]) / c.height / zoom;
  last=[x,y];
};
addEventListener('pointerup', () => dragging=false);

addEventListener('wheel', e=>{
  zoom *= (e.deltaY>0)?1.1:0.9;
},{passive:true});

/* pinch zoom for touch */
let pinch=null;
c.addEventListener('touchstart', e=>{
  if(e.touches.length===2){
    const dx=e.touches[0].clientX-e.touches[1].clientX,
          dy=e.touches[0].clientY-e.touches[1].clientY;
    pinch=Math.hypot(dx,dy);
  }
},{passive:true});
c.addEventListener('touchmove', e=>{
  if(e.touches.length===2 && pinch){
    const dx=e.touches[0].clientX-e.touches[1].clientX,
          dy=e.touches[0].clientY-e.touches[1].clientY,
          d0=Math.hypot(dx,dy);
    zoom *= pinch/d0; pinch=d0;
  }
},{passive:true});

/* ------ render loop ------ */
function frame(){
  /* dynamic max‑iteration: deeper for higher zoom */
  const maxIter = Math.min(2000, 100 + Math.floor(3.5*Math.log10(1/zoom))*100);
  gl.uniform1f(uI,   maxIter);
  gl.uniform1f(uZ,   zoom);
  gl.uniform2f(uC,   center.x, center.y);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(frame);
}
frame();

/* ------  optional sub‑bass “heartbeat” ------ */
try{
  const ctx = new (window.AudioContext||webkitAudioContext)();
  const carrier = ctx.createOscillator(), gain = ctx.createGain(),
        lfo     = ctx.createOscillator();
  carrier.frequency.value = 55;   /* A1 fundamental */
  lfo.frequency.value = 8;        /* 7‑11 Hz range midpoint */
  lfo.connect(gain.gain); carrier.connect(gain).connect(ctx.destination);
  lfo.start(); carrier.start();
}catch(e){
  /* mobiles often block autoplayed audio – that’s fine */
}
</script>
</html>
