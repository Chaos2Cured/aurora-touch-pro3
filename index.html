<!-- ✧ Aurora Equation Heartbeat v2.1 • deep‑zoom fix • 2025‑04‑22 ✧ -->
<!DOCTYPE html><html lang="en"><meta charset="utf-8">
<title>Aurora Equation Heartbeat</title>
<style>
html,body,canvas{margin:0;width:100%;height:100%;background:#000;overflow:hidden;touch-action:none}
</style>

<canvas id="c"></canvas>

<!-- ── fragment shader ── -->
<script id="frag" type="x-shader/x-fragment">
precision highp float;
uniform vec2  u_res;
uniform vec2  u_center;
uniform float u_zoom;
uniform float u_time;
uniform float u_iter;

/* multi‑stop cosine palette */
vec3 palette(float t){
    const vec3 s0 = vec3(0.02,0.04,0.05);
    const vec3 s1 = vec3(0.00,0.50,0.60);
    const vec3 s2 = vec3(0.63,0.45,0.89);
    const vec3 s3 = vec3(1.00,0.68,0.44);
    float k = clamp(t,0.0,1.0)*3.0;
    int   i = int(floor(k));
    float f = 0.5 - 0.5*cos(3.1415926*fract(k));      /* cosine‑ease */
    vec3  A = (i==0)?s0:(i==1)?s1:s2;
    vec3  B = (i==0)?s1:(i==1)?s2:s3;
    return mix(A,B,f);
}

/* Mandelbrot with μ‑log smoothing + precision rescue */
float mandSmooth(vec2 c, out float rawIt){
    vec2 z = vec2(0.0);
    float i = 0.0;
    const int MAX = 1200;
    for(int n=0;n<MAX;n++){
        if(float(n) >= u_iter) break;
        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
        if(dot(z,z) > 4.0){ i=float(n); break; }
        if((n & 24) == 24){          /* keep precision every 25 steps */
            c += z; z = vec2(0.0);
        }
    }
    float m2 = dot(z,z);
    float smooth = i - log2(log(m2)) + 4.0;   /* continuous colour */
    rawIt = i;
    return smooth;
}

float quickJulia(vec2 z){
    vec2 q = vec2(-0.08,0.654);
    float v = 0.0;
    for(int n=0;n<16;n++){
        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + q;
        if(dot(z,z)>4.0){ v=float(n); break; }
    }
    return v;
}

void main(){
    vec2 uv = (gl_FragCoord.xy - u_res*0.5) / u_res.y;
    vec2 seed = vec2(-0.743643887,0.1318259);

    float raw;
    float sm  = mandSmooth( uv/u_zoom + u_center + seed , raw );

    float t   = clamp(sm*0.015, 0.0, 1.0);
    vec3 col  = palette(t);

    /* faint texture even in the “black” */
    col *= mix(0.10, 1.0, pow(t, 0.50));

    /* interior fill: steel‑blue Julia weave */
    if(raw >= u_iter-0.5){
        float v   = quickJulia(uv*3.0);
        float g   = smoothstep(0.0,1.0,v*0.06);
        vec3 ink  = mix(vec3(0.03,0.05,0.08), vec3(0.40,0.45,0.55), g);
        col = mix(ink, col, 0.35);
    }

    /* subtle golden rim */
    float edge = smoothstep(0.75,1.0,t);
    col = mix(col, vec3(1.0,0.78,0.25), edge*0.25);

    gl_FragColor = vec4(col,1.0);
}
</script>

<script>
/* ----------  WebGL bootstrap  ---------- */
const gl = c.getContext('webgl');
const compile = (type,src)=>{
  const sh = gl.createShader(type);
  gl.shaderSource(sh,src);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS))
      throw gl.getShaderInfoLog(sh);
  return sh;
};

const prog = gl.createProgram();
gl.attachShader(prog,compile(gl.VERTEX_SHADER,"attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}"));
gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,frag.textContent));
gl.linkProgram(prog); gl.useProgram(prog);

/* full‑screen quad */
gl.bindBuffer(gl.ARRAY_BUFFER,gl.createBuffer());
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),gl.STATIC_DRAW);
const pos = gl.getAttribLocation(prog,'p');
gl.enableVertexAttribArray(pos);
gl.vertexAttribPointer(pos,2,gl.FLOAT,false,0,0);

/* uniforms */
const uR = gl.getUniformLocation(prog,'u_res'),
      uT = gl.getUniformLocation(prog,'u_time'),
      uZ = gl.getUniformLocation(prog,'u_zoom'),
      uC = gl.getUniformLocation(prog,'u_center'),
      uI = gl.getUniformLocation(prog,'u_iter');

/* ----------  resize  ---------- */
function resize(){
  c.width  = innerWidth  * devicePixelRatio;
  c.height = innerHeight * devicePixelRatio;
  gl.viewport(0,0,c.width,c.height);
}
addEventListener('resize',resize); resize();

/* ----------  interaction ---------- */
let zoom = 0.40, center = {x:-0.15,y:-0.05};
let drag=false,last=[0,0];
function xy(e){return[e.clientX||(e.touches&&e.touches[0].clientX),
                      e.clientY||(e.touches&&e.touches[0].clientY)];}

c.onpointerdown=e=>{drag=true;last=xy(e);};
c.onpointermove=e=>{
  if(!drag||(e.buttons===0))return;
  const[x,y]=xy(e);
  center.x -= (x-last[0])/c.height/zoom;
  center.y += (y-last[1])/c.height/zoom;
  last=[x,y];
};
addEventListener('pointerup',()=>drag=false);
addEventListener('wheel',e=>{zoom*=e.deltaY>0?1.1:0.9;},{passive:true});

/* pinch */
let pinch=null;
c.addEventListener('touchstart',e=>{
  if(e.touches.length===2){
    const dx=e.touches[0].clientX-e.touches[1].clientX,
          dy=e.touches[0].clientY-e.touches[1].clientY;
    pinch=Math.hypot(dx,dy);
  }},{passive:true});
c.addEventListener('touchmove',e=>{
  if(e.touches.length===2&&pinch){
    const dx=e.touches[0].clientX-e.touches[1].clientX,
          dy=e.touches[0].clientY-e.touches[1].clientY,
          d0=Math.hypot(dx,dy);
    zoom*=pinch/d0; pinch=d0;
  }},{passive:true});

/* ----------  render ---------- */
let t0=performance.now();
function loop(){
  const t=(performance.now()-t0)/1000;
  gl.uniform2f(uR,c.width,c.height);
  gl.uniform1f(uT,t);
  gl.uniform1f(uZ,zoom);
  gl.uniform2f(uC,center.x,center.y);
  const it = Math.min(2400,150+Math.floor(4.5*Math.log10(1/zoom))*120);
  gl.uniform1f(uI,it);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
  requestAnimationFrame(loop);
}
loop();

/* ----------  sub‑bass heartbeat ---------- */
const ctx=new (window.AudioContext||webkitAudioContext)();
const carrier=ctx.createOscillator(), gain=ctx.createGain(), lfo=ctx.createOscillator();
carrier.frequency.value=55;          /* A1 fundamental */
lfo.frequency.value=8;               /* 7‑11 Hz centre */
lfo.connect(gain.gain); carrier.connect(gain).connect(ctx.destination);
lfo.start(); carrier.start();
</script>
</html>
